/***************************************************************************

	vidhrdw.c

	Functions to emulate the video hardware of the machine.

***************************************************************************/

/*
 * ported to v0.56
 * using automatic conversion tool v0.01
 */ 
package mame056.vidhrdw;

import static arcadeflex056.fucPtr.*;
import static common.libc.cstring.*;

import static common.ptr.*;
import common.subArrays.IntArray;
import static mame056.common.*;

import static mame056.palette.*;
import static mame056.drawgfx.*;
import static mame056.mame.*;
import static mame056.commonH.*;
import static mame056.drawgfxH.*;

import static mame056.cpuexecH.*;
import static mame056.cpuexec.*;

import static mame056.vidhrdw.generic.*;

// refactor
import static arcadeflex036.osdepend.logerror;

public class tp84
{
	
	
	
	public static UBytePtr tp84_videoram2 = new UBytePtr();
	public static UBytePtr tp84_colorram2 = new UBytePtr();
	static mame_bitmap tmpbitmap2;
	public static UBytePtr dirtybuffer2 = new UBytePtr();
	
	public static UBytePtr tp84_scrollx=new UBytePtr();
	public static UBytePtr tp84_scrolly=new UBytePtr();
	
	static int col0;
	
	/*
	sprites are multiplexed, so we have to buffer the spriteram
	scanline by scanline.
	*/
	public static UBytePtr sprite_mux_buffer = new UBytePtr();
	static int scanline;
	
	
	
	static rectangle topvisiblearea = new rectangle
	(
		0*8, 2*8-1,
		2*8, 30*8-1
        );
	
        static rectangle bottomvisiblearea = new rectangle
	(
		30*8, 32*8-1,
		2*8, 30*8-1
        );
	
	
	
	/*
	-The colortable is divided in 2 part:
	 -The characters colors
	 -The sprites colors
	
	-The characters colors are indexed like this:
	 -2 bits from the characters
	 -4 bits from the attribute in colorram
	 -2 bits from col0 (d3-d4)
	 -3 bits from col0 (d0-d1-d2)
	-So, there is 2048 bytes for the characters
	
	-The sprites colors are indexed like this:
	 -4 bits from the sprites (16 colors)
	 -4 bits from the attribute of the sprites
	 -3 bits from col0 (d0-d1-d2)
	-So, there is 2048 bytes for the sprites
	
	*/
	/*
		 The RGB signals are generated by 3 proms 256X4 (prom 2C, 2D and 1E)
			The resistors values are:
				1K  ohm
				470 ohm
				220 ohm
				100 ohm
	*/
        
        public static int TOTAL_COLORS(int gfxn){
            return (Machine.gfx[gfxn].total_colors * Machine.gfx[gfxn].color_granularity);
        }
	
        public static void COLOR(char[] colortable, int gfxn, int offs, int value){
            colortable[Machine.drv.gfxdecodeinfo[gfxn].color_codes_start + offs]= (char) value;
        }
        
	public static VhConvertColorPromPtr tp84_vh_convert_color_prom = new VhConvertColorPromPtr() {
            public void handler(char[] palette, char[] colortable, UBytePtr color_prom) {
                int i;
                int _palette=0;
		
		for (i = 0;i < Machine.drv.total_colors;i++)
		{
			int bit0,bit1,bit2,bit3;
	
			/* red component */
			bit0 = (color_prom.read(0) >> 0) & 0x01;
			bit1 = (color_prom.read(0) >> 1) & 0x01;
			bit2 = (color_prom.read(0) >> 2) & 0x01;
			bit3 = (color_prom.read(0) >> 3) & 0x01;
			palette[_palette++] = (char) (0x0e * bit0 + 0x1f * bit1 + 0x42 * bit2 + 0x90 * bit3);
			/* green component */
			bit0 = (color_prom.read(Machine.drv.total_colors) >> 0) & 0x01;
			bit1 = (color_prom.read(Machine.drv.total_colors) >> 1) & 0x01;
			bit2 = (color_prom.read(Machine.drv.total_colors) >> 2) & 0x01;
			bit3 = (color_prom.read(Machine.drv.total_colors) >> 3) & 0x01;
			palette[_palette++] = (char) (0x0e * bit0 + 0x1f * bit1 + 0x42 * bit2 + 0x90 * bit3);
			/* blue component */
			bit0 = (color_prom.read(2*Machine.drv.total_colors) >> 0) & 0x01;
			bit1 = (color_prom.read(2*Machine.drv.total_colors) >> 1) & 0x01;
			bit2 = (color_prom.read(2*Machine.drv.total_colors) >> 2) & 0x01;
			bit3 = (color_prom.read(2*Machine.drv.total_colors) >> 3) & 0x01;
			palette[_palette++] = (char) (0x0e * bit0 + 0x1f * bit1 + 0x42 * bit2 + 0x90 * bit3);
	
			color_prom.inc();
		}
	
		color_prom.inc( 2*Machine.drv.total_colors);
		/* color_prom now points to the beginning of the lookup table */
	
	
		/* characters use colors 128-255 */
		for (i = 0;i < TOTAL_COLORS(0)/8;i++)
		{
			int j;
	
	
			for (j = 0;j < 8;j++)
				COLOR(colortable,0,i+256*j, color_prom.read() + 128 + 16*j);
	
			color_prom.inc();
		}
	
		/* sprites use colors 0-127 */
		for (i = 0;i < TOTAL_COLORS(1)/8;i++)
		{
			int j;
	
	
			for (j = 0;j < 8;j++)
			{
				if (color_prom.read()!=0) COLOR(colortable,1,i+256*j, color_prom.read() + 16*j);
				else COLOR(colortable,1,i+256*j, 0);	/* preserve transparency */
			}
	
			color_prom.inc();
		}
            }
        };
	
	/***************************************************************************
	
	  Start the video hardware emulation.
	
	***************************************************************************/
	public static VhStartPtr tp84_vh_start = new VhStartPtr() { public int handler() 
	{
		if (generic_vh_start.handler()!= 0)
			return 1;
	
		if ((dirtybuffer2 = new UBytePtr(videoram_size[0])) == null)
		{
			generic_vh_stop.handler();
			return 1;
		}
		memset(dirtybuffer2,1,videoram_size[0]);
	
		if ((tmpbitmap2 = bitmap_alloc(Machine.drv.screen_width,Machine.drv.screen_height)) == null)
		{
			dirtybuffer2 = null;
			generic_vh_stop.handler();
			return 1;
		}
	
		sprite_mux_buffer = new UBytePtr(256 * spriteram_size[0]);
	
		if (sprite_mux_buffer == null)
		{
			dirtybuffer2 = null;
			bitmap_free(tmpbitmap2);
			generic_vh_stop.handler();
			return 1;
		}
	
		return 0;
	} };
	
	
	
	/***************************************************************************
	
	  Stop the video hardware emulation.
	
	***************************************************************************/
	public static VhStopPtr tp84_vh_stop = new VhStopPtr() { public void handler() 
	{
		sprite_mux_buffer = null;
		sprite_mux_buffer = null;
		dirtybuffer2 = null;
		bitmap_free(tmpbitmap2);
		generic_vh_stop.handler();
	} };
	
	
	
	public static WriteHandlerPtr tp84_videoram2_w = new WriteHandlerPtr() {public void handler(int offset, int data)
	{
		if (tp84_videoram2.read(offset) != data)
		{
			dirtybuffer2.write(offset, 1);
	
			tp84_videoram2.write(offset, data);
		}
	} };
	
	
	
	public static WriteHandlerPtr tp84_colorram2_w = new WriteHandlerPtr() {public void handler(int offset, int data)
	{
		if (tp84_colorram2.read(offset) != data)
		{
			dirtybuffer2.write(offset, 1);
	
			tp84_colorram2.write(offset, data);
		}
	} };
	
	
	
	/*****
	  col0 is a register to index the color Proms
	*****/
	public static WriteHandlerPtr tp84_col0_w = new WriteHandlerPtr() {public void handler(int offset, int data)
	{
		if(col0 != data)
		{
			col0 = data;
	
			memset(dirtybuffer,1,videoram_size[0]);
			memset(dirtybuffer2,1,videoram_size[0]);
		}
	} };
	
	
	
	/* Return the current video scan line */
	public static ReadHandlerPtr tp84_scanline_r  = new ReadHandlerPtr() { public int handler(int offset)
	{
		return scanline;
	} };
	
	
	/***************************************************************************
	
	  Display refresh
	
	***************************************************************************/
	
	static void draw_sprites(mame_bitmap bitmap)
	{
		GfxElement gfx = Machine.gfx[1];
		rectangle clip = Machine.visible_area;
		int offs;
		int line;
		int coloffset = ((col0&0x07) << 4);
	
		for (line = 0;line < 256;line++)
		{
			if (line >= Machine.visible_area.min_y && line <= Machine.visible_area.max_y)
			{
				UBytePtr sr;
	
				sr = new UBytePtr(sprite_mux_buffer, line * spriteram_size[0]);
				clip.min_y = clip.max_y = line;
	
				for (offs = spriteram_size[0] - 4;offs >= 0;offs -= 4)
				{
					int code,color,sx,sy,flipx,flipy;
	
					sx = sr.read(offs);
					sy = 240 - sr.read(offs + 3);
	
					if (sy > line-16 && sy <= line)
					{
						code = sr.read(offs + 1);
						color = (sr.read(offs + 2) & 0x0f) + coloffset;
						flipx = ~sr.read(offs + 2) & 0x40;
						flipy = sr.read(offs + 2) & 0x80;
	
						drawgfx(bitmap,gfx,
								code,
								color,
								flipx,flipy,
								sx,sy,
								clip,TRANSPARENCY_COLOR,0);
					}
				}
			}
		}
	}
	
	
	public static VhUpdatePtr tp84_vh_screenrefresh = new VhUpdatePtr() { public void handler(mame_bitmap bitmap,int full_refresh) 
	{
		int offs;
            int coloffset;

            coloffset = ((col0 & 0x18) << 1) + ((col0 & 0x07) << 6);

            for (offs = videoram_size[0] - 1; offs >= 0; offs--) {
                if (dirtybuffer[offs] != 0) {
                    int sx, sy;

                    dirtybuffer[offs] = 0;

                    sx = offs % 32;
                    sy = offs / 32;

                    drawgfx(tmpbitmap, Machine.gfx[0],
                            videoram.read(offs) + ((colorram.read(offs) & 0x30) << 4),
                            (colorram.read(offs) & 0x0f) + coloffset,
                            colorram.read(offs) & 0x40, colorram.read(offs) & 0x80,
                            8 * sx, 8 * sy,
                            null, TRANSPARENCY_NONE, 0);
                }

                if (dirtybuffer2.read(offs) != 0) {
                    int sx, sy;

                    dirtybuffer2.write(offs, 0);

                    sx = offs % 32;
                    sy = offs / 32;

                    /* Skip the middle of the screen, this ram seem to be used as normal ram. */
                    if (sx < 2 || sx >= 30) {
                        drawgfx(tmpbitmap2, Machine.gfx[0],
                                tp84_videoram2.read(offs) + ((tp84_colorram2.read(offs) & 0x30) << 4),
                                (tp84_colorram2.read(offs) & 0x0f) + coloffset,
                                tp84_colorram2.read(offs) & 0x40, tp84_colorram2.read(offs) & 0x80,
                                8 * sx, 8 * sy,
                                Machine.visible_area, TRANSPARENCY_NONE, 0);
                    }
                }
            }
	
	
		/* copy the temporary bitmap to the screen */
		{
			int scrollx,scrolly;
	
	
			scrollx = -tp84_scrollx.read();
			scrolly = -tp84_scrolly.read();
	
			copyscrollbitmap(bitmap, tmpbitmap, 1, new int[]{scrollx}, 1, new int[]{scrolly}, Machine.visible_area, TRANSPARENCY_NONE, 0);
		}
	
		//draw_sprites(bitmap);
                coloffset = ((col0 & 0x07) << 4);
                for (offs = spriteram_size[0] - 4; offs >= 0; offs -= 4) {
                    int sx, sy, flipx, flipy;

                    sx = spriteram.read(offs + 0);
                    sy = 240 - spriteram.read(offs + 3);
                    flipx = (spriteram.read(offs + 2) & 0x40)!=0?0:1;
                    flipy = spriteram.read(offs + 2) & 0x80;

                    drawgfx(bitmap, Machine.gfx[1],
                            spriteram.read(offs + 1),
                            (spriteram.read(offs + 2) & 0x0f) + coloffset,
                            flipx, flipy,
                            sx, sy,
                            Machine.visible_area, TRANSPARENCY_COLOR, 0);
                }
	
		/* Copy the frontmost playfield. */
		copybitmap(bitmap,tmpbitmap2,0,0,0,0,topvisiblearea,TRANSPARENCY_NONE,0);
		copybitmap(bitmap,tmpbitmap2,0,0,0,0,bottomvisiblearea,TRANSPARENCY_NONE,0);
	} };
	
	
	public static InterruptPtr tp84_6809_interrupt = new InterruptPtr() { public int handler() 
	{
		scanline = 255 - cpu_getiloops();
	
		memcpy(new UBytePtr(sprite_mux_buffer, scanline * spriteram_size[0]),spriteram,spriteram_size[0]);
	
		if (scanline == 255)
			return interrupt.handler();
		else
			return ignore_interrupt.handler();
	} };
}
